defaults:
  - _self_
  - env: insert

name: InsertHolly

physics_engine: ${..physics_engine}

env:
  subtask: ""
  controlType: "Effort"
  actionType: "Static"
  # actionType: "Relative"

  handType : "Gripper"
  complianceAdjust : True

  # if given, will override the device setting in gym.
  numEnvs: ${resolve_default:2048,${...num_envs}}  
  isTest : ${resolve_default:False,${...test}}
 
  envSpacing: 1.2
  evalStats: False  # extra evaluation-time statistics
  clampAbsObservations: 10.0
  useRelativeControl: False  
 
  resetDofPosRandomIntervalArm: 0.1
  resetDofVelRandomIntervalArm: 0.1

  numActions: 7
  actionScale: 0.01  

  controlHz: 60
  simulationHz: 480 
  episodeLength: 120

  forceTarget: -10
  contactBodies: [""]  

  # Need to change
  reachGoalBonus: 10.0
  keypointRewScale: 1.0
  contactRewScale: 1.0
  actionRewScale: 1.0
  frankaActionsPenaltyScale: 0.04
  frankaVelocityPenaltyScale: 0.05  
  frankaTorquesPenaltyScale: 0.0001  
  jointLimitPenaltyScale: 4.0
  
  stiffnessScale: 1.0
  forceLimitScale: 1.0  
  objectBaseSize: 0.01

  # Physics v1, pretty much default settings we used from the start of the project
  # dofFriction: -1.0  # negative values are ignored and the default friction from URDF file is used
  dofFriction: 1.0 
  
  # gain of PD controller (?)
  theHandStiffness: 40.0
  frankaStiffness: 40.0
  
  frankaEffort: [300, 300, 300, 300, 300, 300, 300]  # see Physics v2
  frankaDamping: 5.0
  frankaArmature: 0

  theHandEffort: 0.35  # this is what was used in sim-to-real experiment. Motor torque in Newton*meters
  theHandDamping: 5.0
  theHandArmature: 0
  
  randomizeObjectDimensions: True
  objectType: "block"
  observationType: "full_state"
  bonusTolerance: 0.0019
  initialTolerance: 0.01
  successTolerance: 0.01
  targetSuccessTolerance: 0.005
  toleranceCurriculumIncrement: 0.97  # multiplicative
  toleranceCurriculumInterval: 1000  # in env steps across all agents, with 8192 this is 3000 * 8192 = 24.6M env steps
  maxConsecutiveSuccesses: 120
  successSteps: 1  # how many steps we should be within the tolerance before we declare a success

  saveStates: False
  saveStatesFile: "rootTensorsDofStates.bin"

  loadInitialStates: False
  loadStatesFile: "rootTensorsDofStates.bin"

  asset:
    # Whis was the original kuka_allegro asset.
    # This URDF has some issues, i.e. weights of fingers are too high and the mass of the Allegro hand is too
    # high in general. But in turn this leads to smoother movements and better looking behaviors.
    # Additionally, collision shapes of fingertips are more primitive (just rough convex hulls), which
    # gives a bit more FPS.
    frankaGripper      : "urdf/franka_hand_description/franka_gripper.urdf"        
    frankaShadowHand   : "urdf/franka_shadow_hand_description/franka_shadow_hand.urdf"
    frankaTheHandRight : "urdf/franka_hand_description/franka_right_hand.urdf"    
    frankaTheHandLeft  : "urdf/franka_hand_description/franka_left_hand.urdf"    
    squarePeg     : "urdf/square_peg.urdf"
    squareHole    : "urdf/square_hole.urdf"
    tableBig      : "urdf/table_big.urdf"
    holiTop       : "urdf/holi/holi_top.urdf"
    holiTopCircle : "urdf/holi/holi_top_circle.urdf"
    holiBottom04  : "urdf/holi/holi_bottom_04.urdf"
    holiBottom08  : "urdf/holi/holi_bottom_08.urdf"


    # This is the URDF which has more accurate collision shapes and weights.
    # I believe since the hand is much lighter, the policy has more control over the movement of both arm and
    # fingers which leads to faster training (better sample efficiency). But overall the resulting
    # behaviors look too fast and a bit unrealistic.
    # For sim-to-real experiments this needs to be addressed. Overall, v2 is a "Better" URDF, and it should not
    # lead to behaviors that would be worse for sim-to-real experiments. Most likely the problem is elsewhere,
    # for example the max torques might be too high, or the armature of the motors is too low.
    # The exercise of finding the right URDF and other parameters is left for the sim-to-real part of the project.
    # kukaAllegro: "urdf/kuka_allegro_description/kuka_allegro_v2.urdf"

    assetFileNameBlock: "urdf/objects/cube_multicolor.urdf"

ctrl:
    ctrl_type: task_space_impedance
    # joint_space_impedance
    # {gym_default, joint_space_ik, joint_space_id, task_space_impedance, operational_space_motion, open_loop_force, closed_loop_force, hybrid_force_motion}
                                    
    all:
        gain_space: "task"
        jacobian_type: geometric
        gripper_prop_gains: [500, 500]
        gripper_deriv_gains: [20, 20]
        the_hand_prop_gains: [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]
        the_hand_deriv_gains: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    gym_default:
        ik_method: dls
        joint_prop_gains: [40, 40, 40, 40, 40, 40, 40]
        joint_deriv_gains: [8, 8, 8, 8, 8, 8, 8]
        gripper_prop_gains: [500, 500]
        gripper_deriv_gains: [20, 20]
        the_hand_prop_gains: [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]
        the_hand_deriv_gains: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    joint_space_ik:
        ik_method: dls
        joint_prop_gains: [1, 1, 1, 1, 1, 1]
        joint_deriv_gains: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
    joint_space_id:
        ik_method: dls
        joint_prop_gains: [40, 40, 40, 40, 40, 40]
        joint_deriv_gains: [8, 8, 8, 8, 8, 8, 8]
    task_space_impedance:
        motion_ctrl_axes: [1, 1, 1, 1, 1, 1]      
        franka:
            task_prop_gains: [1000, 1000, 1000, 400, 400, 400]
            task_deriv_gains: [34, 34, 34, 10, 10, 10]
        franka0:
            task_prop_gains: [1000, 1000, 1000, 400, 400, 400]
            task_deriv_gains: [34, 34, 34, 10, 10, 10]
        franka1:
            task_prop_gains: [1000, 1000, 1000, 400, 400, 400]
            task_deriv_gains: [34, 34, 34, 10, 10, 10]        
        gripper:
          joint_prop_gains: [500, 500]
          joint_deriv_gains: [20, 20]        
        the_hand:
          joint_prop_gains: [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500]
          joint_deriv_gains: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20]
        shadow_hand:
          joint_prop_gains: [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500]
          joint_deriv_gains: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20]        
    operational_space_motion:
        motion_ctrl_axes: [1, 1, 1, 1, 1, 1]
        task_prop_gains: [15000, 15000, 15000, 1500, 1500, 1500]
        task_deriv_gains: [200, 200, 200, 20, 20, 20]           
    open_loop_force:
        force_ctrl_axes: [0, 0, 1, 0, 0, 0]
    closed_loop_force:
        force_ctrl_axes: [0, 0, 1, 0, 0, 0]
        wrench_prop_gains: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
    hybrid_force_motion:
        motion_ctrl_axes: [1, 1, 0, 1, 1, 1]        
        force_ctrl_axes: [0, 0, 1, 0, 0, 0]
        task_prop_gains: [15000, 15000, 15000, 100, 100, 100]
        task_deriv_gains: [200, 200, 200, 2, 2, 2]           
        wrench_prop_gains: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]

task:
  randomize: False
  randomization_params:
    frequency: 480   # Define how many simulation steps between generating new randomizations

    observations:
      range: [0, .002] # range for the white noise
      range_correlated: [0, .001 ] # range for correlated noise, refreshed with freq `frequency`
      operation: "additive"
      distribution: "gaussian"
      schedule: "linear"   # "constant" is to turn on noise after `schedule_steps` num steps
      schedule_steps: 40000
    actions:
      range: [0., .05]
      range_correlated: [0, .015] # range for correlated noise, refreshed with freq `frequency`
      operation: "additive"
      distribution: "gaussian"
      schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
      schedule_steps: 40000

    sim_params:
    gravity:
      range: [0, 0.4]
      operation: "additive"
      distribution: "gaussian"
      schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
      schedule_steps: 40000

    actor_params:
      poly:
        color: True
        dof_properties:          
        rigid_body_properties:
          mass:
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 30000
        rigid_shape_properties:
          friction: 
            num_buckets: 250
            range: [0.7, 1.3]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 30000          
      object:
        scale:
          range: [0.5, 2.0]
          operation: "scaling"
          distribution: "uniform"
          schedule: "linear"  # "linear" will scale the current random sample by ``min(current num steps, schedule_steps) / schedule_steps`
          schedule_steps: 1
        rigid_body_properties:
          mass:
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by ``min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 30000
        rigid_shape_properties:
          friction:
            num_buckets: 250
            range: [0.7, 1.3]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 30000

sim:
  substeps: 1  
  up_axis: "z"
  use_gpu_pipeline: ${eq:${...pipeline},"gpu"}
  num_client_threads: 8

  gravity: [0.0, 0.0, -9.81]
  physx:
    num_threads: 6
    solver_type: 1  # 0: pgs, 1: tgs
    num_position_iterations: 16
    num_velocity_iterations: 0

    # max_gpu_contact_pairs: 8388608 # 8*1024*1024
    # max_gpu_contact_pairs: 1048576 # 1*1024*1024
    max_gpu_contact_pairs: 262144 # 1*512*512
    num_subscenes: ${....num_subscenes}
    contact_offset: 0.002
    rest_offset: 0.0
    bounce_threshold_velocity: 0.2
    max_depenetration_velocity: 5.0
    default_buffer_size_multiplier: 25.0
    contact_collection: 1 # 0: CC_controller_optionsNEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)
    friction_offset_threshold: 0.002
    # friction_correlation_distance: 0.00625
